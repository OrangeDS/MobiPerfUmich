package eecs.umich.threegtest;
import android.content.Context;
import android.net.wifi.WifiManager;
import android.os.PowerManager;
import android.provider.Settings;
import android.util.Log;


class Service_Thread extends Thread {
    public static int mProgressStatus;
    
    //public static final String FILENAME = "messagefile.txt";
    public static final String LOG_FILE_NAME = "UMLogger.txt";
    public static final String LAST_LOG_FILE_NAME = "UMLogger_last.txt";
    //private static String uiFile = "uiprint.txt";
    public static boolean pingFlag = true;
    
    public static int rPorts = 0;
    public static int[] PORTS = new int [] {21, 22, 25, 53, 80, 
    	110, 135, 139, 143, 161, 
    	443, 445, 465, 585, 587, 
    	993, 995, 5060, 6881, 5223, 
    	5228, 8080};
    public static boolean [] REACHB = new boolean[ PORTS.length ];
    public static char [] REACHBst = new char[ PORTS.length ];

    
    public static String infoS;
    
	
    //private static final int PORT_CACHING = 6000;   
    
    private static final String[] PORT_NAMES = new String[] {"FTP", "SSH", "SMTP", "DNS", "HTTP",
    	"POP", "RPC", "NETBIOS", "IMAP", "SNMP", 
    	"HTTPS",  "SMB", "SMTP SSL", "Secure IMAP", "Auth SMTP", 
    	"IMAP SSL", "POP SSL", "SIP", "BITTORRENT", "IOS SPECIAL",
    	"ANDROID SPECIAL", "HTTP PROXY"};

    
    public static Threegtest_Service service;
    private static NAT_Test_Thread natThread;
    private static TCP_Injection_Vuln_Test_Thread tcpInjectionVulnTestThread;
    private static Spoof_Test_Thread spoofThread;
    private static Probe_Nearby_Test_Thread probeNearbyThread;
    private static Timeout_Test_Thread timeoutThread;
    private static Firewall_Test_Thread firewallThread;
    
    
    private long strt;
    private long endt;
    private long totaltime;
    private PowerManager.WakeLock wakeLock;
    private WifiManager.WifiLock wlw;

	public Service_Thread(Threegtest_Service s){
		this.service = s;
		mProgressStatus = 0;
	}
		
        public void run() {
        	
        	Definition.reset();
        	
        	Thread binaryThread = Utilities.installBinaries(service);
        	
        	service.updateTextView3("Checking if airplane is enabled...");
        	boolean isEnabled = Settings.System.getInt( service.getContentResolver(), Settings.System.AIRPLANE_MODE_ON, 0 ) == 1;
        	if ( isEnabled ) {
        		Log.v("3gtest", "airplane mode enabled!!!!!!!!!!!!!!!");
        		mProgressStatus = 0;
                String message = "Airplane mode enabled, network cannot be used.";
                
                //Utilities.write_to_file(FILENAME, Context.MODE_APPEND ,message + "\n"+mProgressStatus + "\n", context );
                // Write results into UMLogger.txt
            	//Utilities.write_to_file(LOG_FILE_NAME, Context.MODE_APPEND, message + "\n", context );
            	//Utilities.sendudpmessage( uiFile, "" + message.length() + "!" + message + "" + mProgressStatus + "!", context );
            	// Store in service and update the activity UI
            	service.addResultAndUpdateUI(message, mProgressStatus);
            	return;
        	}
        	long startTime = System.currentTimeMillis();
        	
        	
        	service.updateTextView3("Checking GPS...");
            while(GPS.location == null){
            	long endTime = System.currentTimeMillis();
            	if(endTime-startTime>6000)
            	{
            		GPS.stopAllUpdate();
            		GPS.location = GPS.getCurrentLocation();
            		GPS.latitude = GPS.location.getLatitude();
            		GPS.longitude = GPS.location.getLongitude();
            		break;
            	}
            	try {
            		//Log.v("LOG", "Utilities.Info(), waiting for a GPS result............");
    				Thread.sleep(1000);
    			} catch (InterruptedException e) {
    				e.printStackTrace();
    			}
            }
        	
        	//Threegtest_Service.tester = new ConnectivityThreegtest_Service.tester(context);
        	//Utilities.write_to_file("seeifrunning.txt", Context.MODE_APPEND, ""+Utilities.time()+"\n", context);
            PowerManager pm = ( PowerManager ) service.getSystemService( Context.POWER_SERVICE );
            
            wakeLock = pm.newWakeLock( PowerManager.PARTIAL_WAKE_LOCK, "My Tag" );
            WifiManager wm = ( WifiManager ) service.getSystemService( Context.WIFI_SERVICE );
            wlw = wm.createWifiLock( "yes TAG" );
            //deviceID = wm.getConnectionInfo().getMacAddress();
            //threegtest.stopFlag = false;
            
            this.setPriority( MAX_PRIORITY );
            // int roundRunning = 0;
            // long version = System.currentTimeMillis();
            //long gotversion = 0;
            //Utilities.write_to_file("versionfile.txt", Context.MODE_WORLD_READABLE,"" + version + "\n", context);
            long repeattime = -1;
            
            do{
            	
                wakeLock.acquire();
                wlw.acquire();

               // try {
               // 	String line = "";
                	//mhayter
               // 	BufferedReader bufferedReader = new BufferedReader (new InputStreamReader ( context.openFileInput("versionfile.txt")));
               // 	line = bufferedReader.readLine();
                    //gotversion = new Long( line );
               // }
                // catch ( Exception e ) {}

                //if ( gotversion != version )
                //    return ;
                //roundRunning++;
                //Utilities.write_to_file("roundfile.txt", Context.MODE_WORLD_READABLE,"" + roundRunning + "\n", context);
                pingFlag = true;
                
                if(shouldStop())
                	return;
                
                service.updateTextView3("Checking network connection...");
                if ( Utilities.checkConnection() == -1 ) {
                    Threegtest_Service.tester.setNetworkStatus(false);
                    Log.v("LOG", "check connection failed!!!!!!!!!!!!");
                }
                else {
                	Threegtest_Service.tester.setNetworkStatus(true);
                	Log.v("LOG", "check connection successful!!!!!!!!");
                }
   
               
                if ( Threegtest_Service.tester.getNetworkStatus() == true )
                {
                	//network connection is available, start tests
                    strt = System.currentTimeMillis();
                    totaltime = 0;
                    
                    
                    infoS = Utilities.Info(service);
                    
                    // set report prefix
                    (new Report()).sendReport(infoS);
                    
                    if(shouldStop())
                    	return;
                    
                    //MobiOpen test
                	service.updateTextView3("MobiPerf local experiments");
                	if(1==1){
                		while(true){
                			long start = System.currentTimeMillis();
                			localExperiments("rtt.size");
                			service.updateTextView2("querying " + System.currentTimeMillis());
                			//DNS.LookupUniqueUrl(true);
                		}
                	}
                	if(1==1)
                		return;//*/
                   
                    
                    String netInfoS = "NETWORK:" + "<Carrier:" + Threegtest_Service.tester.getNetworkOperator();
                    mProgressStatus = 5; 
                    String message = "Network type: ";
                    
                    String[] networkType = Threegtest_Service.tester.getTypeNameAndId();
                    
                    message += networkType[0];
                    
                    netInfoS += "><Type:" + networkType[0] + 
                    			"><TypeID:" + networkType[1] + 
                    			"><CellId:"+Threegtest_Service.tester.getCellId()+
                    			"><Signal:"+Threegtest_Service.tester.getSS()+">;";
                    //Utilities.write_to_file(FILENAME, Context.MODE_WORLD_READABLE,message + "\n"+"" + mProgressStatus + "\n", context);
                    // Create UMLogger.txt and first add a Timestamp
                    //Utilities.write_to_file(LOG_FILE_NAME, Context.MODE_WORLD_READABLE, "Log time: " + Utilities.getCurrentLocalTime() + "\n", service );
                    //Utilities.write_to_file(LOG_FILE_NAME,Context.MODE_APPEND, message+"\n", service);
                    //Utilities.sendudpmessage( uiFile, "" + message.length() + "!" + message + "" + mProgressStatus + "!", context );
                    service.addResultAndUpdateUI(message, mProgressStatus);//NetworkType
                    mProgressStatus = 10;
                    message = "GPS: "+Math.abs(GPS.latitude);
                    if(GPS.latitude > 0)
                    	message += "N";
                    else if(GPS.latitude < 0)
                    	message += "S";
                    message+=(", "+Math.abs(GPS.longitude));
                    if(GPS.longitude > 0)
                    	message += "E";
                    else if(GPS.longitude < 0)
                    	message += "W";
                    //Utilities.write_to_file(FILENAME, Context.MODE_APPEND,message + "\n"+"" + mProgressStatus + "\n", context);
                    //Utilities.write_to_file(LOG_FILE_NAME,Context.MODE_APPEND,message+"\n", service);
                    
                    //Utilities.sendudpmessage( uiFile, "" + message.length() + "!" + message + "" + mProgressStatus + "!", context );
                    service.addResultAndUpdateUI(message, mProgressStatus);//GPS
                    
                    (new Report()).sendReport(netInfoS);
                    
                    DNS.LookupUniqueUrl(false);

                    if(shouldStop())
                    	return;

                    //local ip vs global ip
                    if(service.isRoot)
                    {
                    	service.updateTextView3("Testing IP, NAT, and firewall with root...");
                    }
                    else
                    {
                    	service.updateTextView3("Testing IP, NAT, and firewall...");
                    }
                    int replyCode = Phone_IPs.Get_Phone_IPs(Definition.SERVER_NAME, Definition.PORT_WHOAMI );

                    if(shouldStop())
                    	return;

                    String result = "ADDRESS:";
                    result += "<LocalIp:" + Phone_IPs.localIP + ">:<GlobalIp:" + Phone_IPs.seenIP + ">;";
                    String message1;
                    if ( replyCode >= 7 ) {
                        message = "Local IP address: " +Phone_IPs.localIP;
                        message1 = "Global IP address: " + Phone_IPs.seenIP;
                    }
                    else {
                        message = "Local IP address: Error in test";
                        message1 = "Global IP address: Error in test";
                    }
                   
                    //Utilities.write_to_file(FILENAME, Context.MODE_APPEND,message + "\n" + mProgressStatus + "\n"+ message1 + "\n"+ mProgressStatus + "\n", context);
                    //Utilities.sendudpmessage( uiFile, "" + message.length() + "!" + message + "" + mProgressStatus + "!", context );
                    service.addResultAndUpdateUI(message, mProgressStatus);//Local IP
                    Utilities.write_to_file(LOG_FILE_NAME,Context.MODE_APPEND,message+"\n"+message1 + "\n", service );
                   // Utilities.sendudpmessage( uiFile, "" + message1.length() + "!" + message1 + "" + mProgressStatus + "!", context );
                    service.addResultAndUpdateUI(message1, mProgressStatus);//Global IP
                    result += "\n";
                    (new Report()).sendReport(result);
                    
                    endt = System.currentTimeMillis();
                    totaltime += ( endt - strt );

                    
                    /**** wait till all the binaries are installed ****/
                    try {
						binaryThread.join();
					} catch (InterruptedException e3) {
						e3.printStackTrace();
					}
                    /*********** NAT Test Thread **************/
                    // Make sure only one NAT_Test_Thread instance is running
                    if(natThread == null || !natThread.isAlive())
                    {
                    	natThread = new NAT_Test_Thread(service);
                    	natThread.start();
                    }
                    else
                    {
                    	if(natThread.isMappingDone)
                    	{
                    		message = natThread.getNATMappingMessage();
                    		service.addResultAndUpdateUI(message, mProgressStatus);
                    		Utilities.write_to_file(Service_Thread.LOG_FILE_NAME,Context.MODE_APPEND, message+"\n", service);
                    	}
                    	Log.v("3gtest_nat", "nat thread is still running");
                    }
                    /******************************************/
                    /*********** Timeout Test Thread **************/
                    // Make sure only one NAT_Test_Thread instance is running
                    if(timeoutThread == null || !timeoutThread.isAlive())
                    {
                    	timeoutThread = new Timeout_Test_Thread(service);
                    	timeoutThread.start();
                    }
                    else
                    {
                    	Log.v("3gtest_timeout", "timeout thread is still running");
                    }
                    /******************************************/
                    
                    
                    // Similar to NAT thread (testing TCP injection vulnerability)
                	if(tcpInjectionVulnTestThread == null || !tcpInjectionVulnTestThread.isAlive())
                    {
                		tcpInjectionVulnTestThread = new TCP_Injection_Vuln_Test_Thread(service);
                		Log.v("TCPvultest", "TCPvultest starts to run!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                		tcpInjectionVulnTestThread.start();
                    }
                    else
                    {
                    	Log.v("TCPvultest", "TCPvultest thread is still running");
                    }
                	
                    
                    
                    // Similar to NAT thread (probing nearby IPs)
                	if(probeNearbyThread == null || !probeNearbyThread.isAlive())
                    {
                		probeNearbyThread = new Probe_Nearby_Test_Thread(service);
                		probeNearbyThread.start();
                    }
                    else
                    {
                    	Log.v("probeNearbyThread", "probeNearbyThread test thread is still running");
                    }
                    
                    if(service.isRoot)
                    {
                    	/************* IP Spoofing Test ***********/
                    	// Similar to NAT thread
                    	if(spoofThread == null || !spoofThread.isAlive())
                        {
                        	spoofThread = new Spoof_Test_Thread(service);
                        	spoofThread.start();
                        }
                        else
                        {
                        	Log.v("3gtest_spoof", "spoof test thread is still running");
                        }
                    	/******************************************/
                    	/************* Firewall Buffer Test ***********/

                    	// Similar to NAT thread
                    	if(firewallThread == null || !firewallThread.isAlive())
                        {
                    		firewallThread = new Firewall_Test_Thread(service);
                    		firewallThread.start();
                        }
                        else
                        {
                        	Log.v("3gtest_firewall", "firewall test thread is still running");
                        }
                    	/******************************************/
                    }
                    
                    
                    if(shouldStop())
                    	return;

                    
                    
                    strt = System.currentTimeMillis();
                    // DNS request google
                    service.updateTextView3("Testing local DNS server...");
                    replyCode = DNS.Google();

                    if(shouldStop())
                    	return;

                    if ( DNS.DNSGoogle == true ) {
                        message = "Local DNS server status: UP";
                    }
                    else {
                        message = "Local DNS server status: DOWN";
                    }
                    mProgressStatus = 30;
                    //Utilities.write_to_file(FILENAME, Context.MODE_APPEND,message + "\n"+ mProgressStatus + "\n", context );
                    Utilities.write_to_file(LOG_FILE_NAME, Context.MODE_APPEND,message + "\n", service);
                    //Utilities.sendudpmessage( uiFile, "" + message.length() + "!" + message + "" + mProgressStatus + "!", context );
                    service.addResultAndUpdateUI(message, mProgressStatus);//Local DNS server status
                    strt = System.currentTimeMillis();
                    
                    // popular domains
                    Parallel_Thread1.thread1DoneFlag = false;
                    Parallel_Thread2.thread2DoneFlag = false;
                    Landmark.config_file_check(service, Definition.SERVER_NAME);

                    if(shouldStop())
                    	return;
                    
                    service.updateTextView3("Testing network latencies...");
                    Thread p1 = new Parallel_Thread1(service);
                    p1.start();
                    Thread p2 = new Parallel_Thread2(service);
                    p2.start();
                    try {
                    	// Service_Thread waits Paralel_Thread1
						p1.join();
					} catch (InterruptedException e1) {
						e1.printStackTrace();
					}
					service.updateTextView3("Testing network latencies...");
                    try {
                    	// Service_Thread waits Paralel_Thread2
						p2.join();
					} catch (InterruptedException e1) {
						e1.printStackTrace();
					}

                    endt = System.currentTimeMillis();
                    totaltime += ( endt - strt );
                    
                    if(shouldStop())
                    	return;

                    strt = System.currentTimeMillis();
                    result = "DNS:";
                    // DNS UMICH
                    replyCode = DNS.Umich(Definition.SERVER_NAME, Definition.PORT_DNS_UDP);

                    if(shouldStop())
                    	return;
                    
                    mProgressStatus = 50;
                    
                    //TODO Junxian ???? why set to true and then check true ????
                    //DNS.DNSUmich = true; //commented by Junxian on April 22, 2011
                    if ( DNS.DNSUmich == true ) {
                        message = "DNS lookup to external server allowed?: Yes";
                        result += "<DnsToExternalServerAllowed: Yes>";
                    }
                    else if ( replyCode == 6 ) {
                        message = "DNS lookup to external server allowed?: No";
                        result += "<DnsToExternalServerAllowed: No>";
                    }
                    else if ( replyCode == 4 ) {
                        message = "DNS lookup to external server allowed?: No";
                        result += "<DnsToExternalServerAllowed: No>";
                    }
                    else {
                        message = "DNS lookup to external server allowed?: Error in test";
                        result += "<DnsToExternalServerAllowed: Error in test>";
                    }
                    //Utilities.write_to_file(FILENAME, Context.MODE_APPEND,message + "\n"+ mProgressStatus + "\n", context );
                    Utilities.write_to_file(LOG_FILE_NAME, Context.MODE_APPEND,message + "\n", service);
                    //Utilities.sendudpmessage( uiFile, "" + message.length() + "!" + message + "" + mProgressStatus + "!", context );
                    service.addResultAndUpdateUI(message, mProgressStatus);//DNS lookup to external server
                    result += ";";
                    result += "\n";
                    (new Report()).sendReport(result);
                    
                    if(shouldStop())
                    	return;
                    
                    //signal
                    service.updateTextView3("Testing signal quality...");
                    if ( pingFlag ) {
                    	Traceroute.latitude_2ndhop();

                    	if(shouldStop())
                        	return;

                        message = "Signal quality from 0 (low) to 10 (high): " + ( 10 - Traceroute.lossRateServers[ 0 ] );

                        if ( 10 - Traceroute.lossRateServers[ 0 ] > 8 )
                            message += " Good";
                        else if ( 10 - Traceroute.lossRateServers[ 0 ] > 5 )
                            message += " Moderate";
                        else
                            message += " Bad";
                    }
                    else {
                        message = "Signal quality from 0 (low) to 10 (high): Cannot run test, your provider blocks outgoing Ping Packets";
                    }
                    //should be around 24
                    mProgressStatus = 60;
                    //Utilities.write_to_file(FILENAME, Context.MODE_APPEND,message + "\n"+ mProgressStatus + "\n", context );
                    //Utilities.write_to_file(LOG_FILE_NAME, Context.MODE_APPEND,message + "\n", service);
                    //Utilities.sendudpmessage( uiFile, "" + message.length() + "!" + message + "" + mProgressStatus + "!", context );
                    service.addResultAndUpdateUI(message, mProgressStatus);//Signal strength
                    endt = System.currentTimeMillis();
                    totaltime += ( endt - strt );

                    if(shouldStop())
                    	return;

                    // HTTP proxy caching tests (currently disabled to speed up the test)

                   /* strt = System.currentTimeMillis();

                    replyCode = Caching_Compression.http_caching(HTTP_SERVER_IP, PORT_CACHING);

                    if(shouldStop())
            			return;

                    result = "HTTP:";

                    if ( replyCode != 12 ) {
                        message = "HTTP caching detection: Error in test";
                        result += "<Cache: Error>:";
                    }
                    else {
                        if ( Caching_Compression.cacheFlag == true ) {
                            message = "HTTP caching detection: Detected";
                            result += "<Cache: Yes>:";
                        }
                        else {
                            message = "Http Caching detection: Not detected";
                            result += "<Cache: No>:";
                        }
                    }

                    if(shouldStop())
            			return;
                    

                    strt = System.currentTimeMillis();

                    if ( replyCode != 12 ) {
                        message = "Http Proxy detection: Error in test";
                        result += "<Compression: Error>;";
                    }
                    else {
                        if ( Caching_Compression.compressionFlag == true ) {
                            message = "Http Proxy detection: Detected";
                            result += "<Compression: Yes>;";
                        }
                        else {
                            message = "Http Proxy detection: Not detected";
                            result += "<Compression: No>;";
                        }
                    }
                    result += "\n";
                    Report.sendReport( serverIP, result, PORT_CONTROL );
                    */
                    
                    
                    
                    // bit torrent differentiation (currently disabled to speed up the test)

                    /*
                    if(shouldStop())
            			return;

                    //// random bit torrent
                    replyCode = BT.BTptosUp( serverIP, PORT_BT_RAND, context );

                    if(shouldStop())
            			return;

                    result = "BT:";

                    if ( BT.BTBlockedStage.equals( "E" ) ) {
                        message = "BitTorrent uplink traffic: No blocking ";
                        result += "<NondftUpBlockedStage: NONE>;";
                    }
                    else if ( BT.BTBlockedStage.equals( "S" ) ) {
                        message = "BitTorrent uplink traffic: Error in test";
                        result += "<NondftUpBlockedStage: Error>;";
                    }
                    else {
                        message = "BitTorrent uplink traffic: Blocked ";
                        result += "<NondftUpBlockedStage: " + BT.BTBlockedStage + ">;";
                    }

                    result += "\n";
                    Report.sendReport( serverIP, result, PORT_CONTROL );

                    if(shouldStop())
            			return;


                    replyCode = BT.BTptosUp( serverIP, PORT_BT , context );

                    if(shouldStop())
            			return;

                    result = "BT:";

                    if ( BT.BTBlockedStage.equals( "E" ) ) {
                        message = "BitTorrent uplink traffic: No blocking ";
                        result += "<DftUpBlockedStage: None>;";
                    }
                    else if ( BT.BTBlockedStage.equals( "S" ) ) {
                        message = "BitTorrent uplink traffic: Error in test";
                        result += "<DftUpBlockedStage: Error>;";
                    }
                    else {
                        message = "BitTorrent uplink traffic: Blocked ";
                        result += "<DftUpBlockedStage: " + BT.BTBlockedStage + ">;";
                    }
                    
                    mProgressStatus = Utilities.setProgressStatus (42);
                    Utilities.write_to_file(FILENAME, Context.MODE_APPEND,message + "\n"+ mProgressStatus + "\n", context );
                    Utilities.write_to_file(LOG_FILE_NAME, Context.MODE_APPEND,message + "\n", context);
                    Utilities.sendudpmessage( uiFile, "" + message.length() + "!" + message + "" + mProgressStatus + "!", context );
                    if ( Utilities.destinationreached == false )
                    	Traceroute.method(serverIP, PORT_CONTROL,5, 10);
                    result += "\n";
                    Report.sendReport( serverIP, result, PORT_CONTROL );
                    
					if(shouldStop())
            			return;
                    replyCode = BT.BTptosDown( serverIP, PORT_BT_RAND, context );
                    
				
					if(shouldStop())
            			return;
            	
                    result = "BT:";
                    if ( BT.BTBlockedStage.equals( "E" ) ) {
                        message = "BitTorrent downlink traffic: No blocking ";
                        result += "<NondftDownBlockedStage: None>;";
                    }
                    else if ( BT.BTBlockedStage.equals( "S" ) ) {
                        message = "BitTorrent downlink traffic: Error in test";
                        result += "<NondftDownBlockedStage: Error>;";
                    }
                    else {
                        message = "BitTorrent downlink traffic: Blocked at " +BT.BTBlockedStage;
                        result += "<NondftDownBlockedStage: " + BT.BTBlockedStage + ">;";
                    }
                    result += "\n";
                    Report.sendReport( serverIP, result, PORT_CONTROL );

                    if(shouldStop())
            			return;

                    result = "BT:";

                    replyCode = BT.BTptosDown( serverIP, PORT_BT , context );

                    if(shouldStop())
            			return;

                    if ( BT.BTBlockedStage.equals( "E" ) ) {
                        message = "BitTorrent downlink traffic: No blocking ";
                        result += "<DftDownBlockedStage: None>;";
                    }
                    else if ( BT.BTBlockedStage.equals( "S" ) ) {
                        message = "BitTorrent downlink traffic: Error in test";
                        result += "<DftDownBlockedStage: Error>;";
                    }
                    else {
                        message = "BitTorrent downlink traffic: Blocked ";
                        result += "<DftDownBlockedStage: " + BT.BTBlockedStage + ">;";
                    }

                    mProgressStatus = Utilities.setProgressStatus (56);
                    Utilities.write_to_file(FILENAME, Context.MODE_APPEND ,message + "\n"+mProgressStatus + "\n", context );
                    Utilities.write_to_file(LOG_FILE_NAME, Context.MODE_APPEND,message + "\n", context );
                    Utilities.sendudpmessage( uiFile, "" + message.length() + "!" + message + "" + mProgressStatus + "!", context );
                    if ( Utilities.destinationreached == false )
                    	Traceroute.method(serverIP, PORT_CONTROL,10,15);
                    result += "\n";
                    Report.sendReport( serverIP, result, PORT_CONTROL );
                    endt = System.currentTimeMillis();
                    totaltime += ( endt - strt );
                    
                    if(shouldStop())
            			return;

                    strt = System.currentTimeMillis();
                    
                    /// random


                    replyCode = BT.BTRandom( serverIP, PORT_BT );

                    if(shouldStop())
            			return;

                    result = "BT:";
                    
                    if ( replyCode < 5 ) {
                        result += "<RandomBlockedStage: SYN>;";
                    }
                    else if ( replyCode < 10 ) {
                        result += "<RandomBlockedStage: Transfer>;";
                    }
                    else {
                        result += "<RandomBlockedStage: None>;";
                    }

                    result += "\n";
                    Report.sendReport( serverIP, result, PORT_CONTROL );

                    if(shouldStop())
            			return;

                    replyCode = HTTP.HTTPptosUp( serverIP, PORT_HTTP, context );

                    if(shouldStop())
            			return;


                    replyCode = HTTP.HTTPptosDown( serverIP, PORT_HTTP, context );

                    if(shouldStop())
            			return;
*/
                    
                   
                    
                    ///reachability test wrapper
                    //no reachability test for now
                    //if(testReachability())
                    //	return;
                    
                    
                    strt = System.currentTimeMillis();
                    
                    // downlink tput
                    service.updateTextView3("Testing downlink throughput...");
                    replyCode = Throughput.MeasureDownlinkTput(Definition.SERVER_NAME, Definition.PORT_THRU_DOWN);

                    if(shouldStop())
                    	return;

                    result = "DOWN:";

                    if ( replyCode == 7 ) {
                    	
                    	double downtp = (Throughput.downlinkSize * 8 ) / Throughput.downlinkTime; // in kbps
                    	
                        message = "TCP downlink bandwidth (kbps): " + downtp;
                        result += "<Tp:" + downtp + ">";

                        
                        if ( downtp > 500 )
                            message += " Good";
                        else if ( downtp > 130 )
                            message += " Moderate";
                        else
                            message += " Bad";
                    }
                    else {
                        message = "TCP downlink bandwidth (kbps): Network problem in test";
                        result += "<Tp:-1>";
                    }
                    
                    mProgressStatus = 90;
                	//Utilities.write_to_file(FILENAME, Context.MODE_APPEND ,message + "\n"+mProgressStatus + "\n" , context);
                	//Utilities.write_to_file(LOG_FILE_NAME, Context.MODE_APPEND,message + "\n", service );
                	//Utilities.sendudpmessage( uiFile, "" + message.length() + "!" + message + "" + mProgressStatus + "!", context );
                	
                    service.addResultAndUpdateUI(message, mProgressStatus);//TCP down
                	result += ";";
                    result += "\n";
                    (new Report()).sendReport(result);
                    
                    // uplink tput   
                    service.updateTextView3("Testing uplink throughput...");
                    

                    if(shouldStop())
                    	return;
                    
                    replyCode = Throughput.MeasureUplinkTput(Definition.SERVER_NAME, Definition.PORT_THRU_UP);
                    

                    if(shouldStop())
                    	return;

                    result = "UP:";

                    if ( replyCode == 7 ) {
                    	//double uptp = Throughput.uplinkSize / ( 128 * 60 );//old mistaken one
                    	double uptp = (Throughput.uplinkSize * 8) / Throughput.uplinkTime;
                    	message = "TCP uplink bandwidth (kbps): " + uptp;
                        result += "<Tp:" + uptp + ">";

                        if ( uptp > 100 )
                            message += " Good";
                        else if ( uptp > 30 )
                            message += " Moderate";
                        else
                            message += " Bad";
                    }
                    else {
                        message = "TCP uplink bandwidth (kbps): Network problem in test";
                        result += "<Tp:-1>";
                    }

                    mProgressStatus = 100;
                    result += ";";
                    result += "\n";
                    (new Report()).sendReport(result);

                   
                    
                    Log.v("error"," dis is "+message);
                    //Utilities.write_to_file(FILENAME, Context.MODE_APPEND ,message + "\n"+mProgressStatus + "\n", context );
                	//Utilities.write_to_file(LOG_FILE_NAME, Context.MODE_APPEND,message + "\n", service );
                	//Utilities.sendudpmessage( uiFile, "" + message.length() + "!" + message + "" + mProgressStatus + "!", context );  
                	service.addResultAndUpdateUI(message, mProgressStatus);//TCP UP
                	
                	if(shouldStop())
                    	return;
                	
                	//traceroute experiments to our server
                	//TODO
                	//Traceroute.traceroute(Def.SERVER_NAME, -1, -1);
                	
                }
                else	// No network connection 
                {
                    mProgressStatus = 0;
                    String message = "It seems that your network is down";
                    //Utilities.write_to_file(FILENAME, Context.MODE_APPEND ,message + "\n"+mProgressStatus + "\n", context );
                	//Utilities.write_to_file(LOG_FILE_NAME, Context.MODE_APPEND,message + "\n", context );
                	//Utilities.sendudpmessage( uiFile, "" + message.length() + "!" + message + "" + mProgressStatus + "!", context );
                	service.addResultAndUpdateUI(message, mProgressStatus);//network problem
                }
                mProgressStatus = 100;
             
                wakeLock.release();
                wlw.release();


            }while ( repeattime != -1 );


            //Utilities.sendudpmessage( uiFile, "1001!", context );

            //Utilities.sendudpmessage( "killsocket.txt", "kill", context );
            long endTime = System.currentTimeMillis();
            Log.v("3gtest", "service thread finish using " + (endTime-startTime)/1000 +"s");
            
        }
        
        
        /**
         * For FCC challenge or local experiments
         * Test both latency to TCP and UDP server with the list of ports
         * @return
         */
        public void localExperiments(String type){
        	
        	if(type.equalsIgnoreCase("port.scan")){
	            for(int j = 0; j < PORTS.length; j++){
	                new Port_Scan(j).rttWithPacketSize(100, 50, Port_Scan.DIRECTION_DOWN);
	            }
        	}else if(type.equalsIgnoreCase("rtt.size")){
        		int NUM_EXP = 10;
        		for(int s = 75 ; s < 5000 ; s += 25){
        			for(int direction : new int[]{Port_Scan.DIRECTION_DOWN, 
        					Port_Scan.DIRECTION_UP, Port_Scan.DIRECTION_BOTH}){
			    		new Port_Scan(0).rttWithPacketSize(s, NUM_EXP, direction);//port 21
			    		new Port_Scan(3).rttWithPacketSize(s, NUM_EXP, direction);//port 53
			    		new Port_Scan(20).rttWithPacketSize(s, NUM_EXP, direction);//port 5228
        			}
        		}
        	}
        }
        
        
        /**
         * Test reachability of PORTS.length ports
         * @return true when stop button clicked and should return for upper layer
         */
        
        public boolean testReachability(){
        	strt = System.currentTimeMillis();
            service.updateTextView3("Testing port blocking...");
            rPorts = 0;

            for(int j = 0; j < PORTS.length; j++){
            	
            	if(shouldStop())
                	return true;
            	
                new Port_Scan(j).start();
                
                
                //wait a little while before staring new thread
                try {
					Thread.sleep(100);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
            }

            do {
            	if(shouldStop())
                	return true;

                try {
                	//sleep for 1 sec
                    Thread.sleep( 1000 );
                }catch ( InterruptedException e ) {
                    e.printStackTrace();
                }
            }while(rPorts < PORTS.length);

            if(shouldStop())
            	return true;

            String message = "";
            String result = "REA";
            message = "Blocked ports for direct access: ";
            String message1 = "Allowed ports for direct access: ";

               
            for ( int i = 0; i < REACHB.length;i++ ) {
                result += ":";
                Log.v("LOG", "REACHB result " + i + " for port " + PORTS[i] + " is " + REACHB[i]);
                if ( REACHB[ i ] == false ) {
                    message += PORTS[ i ] + " (" + PORT_NAMES[ i ] + ")" + " ";
                    if ( REACHBst[ i ] == 'c' )
                        result += "<" + PORTS[ i ] + ": CONNECT>";
                    else
                        result += "<" + PORTS[ i ] + ": RECV>";
                }
                else {
                    message1 += PORTS[ i ] + " (" + PORT_NAMES[ i ] + ")" + " ";
                    result += "<" + PORTS[ i ] + ": OK>";
                }
            }

            mProgressStatus = 80;
            //Utilities.write_to_file(FILENAME, Context.MODE_APPEND ,message + "\n"+mProgressStatus + "\n"+message1 + "\n"+mProgressStatus + "\n", context );
            //Utilities.sendudpmessage( uiFile, "" + message.length() + "!" + message + "" + mProgressStatus + "!", context );
            service.addResultAndUpdateUI(message, mProgressStatus);//disallowed ports
            Utilities.write_to_file(LOG_FILE_NAME, Context.MODE_APPEND, message + "\n"+message1 + "\n", service  );
            //Utilities.sendudpmessage( uiFile, "" + message1.length() + "!" + message1 + "" + mProgressStatus + "!", context );
            service.addResultAndUpdateUI(message1, mProgressStatus);//allowed ports
            result += ";";
            result += "\n";
            (new Report()).sendReport(result);
            endt = System.currentTimeMillis();
            totaltime += ( endt - strt );
            
            if(shouldStop())
            	return true;
            
            return false;
        }
        
        
        /**
         *  use this to check stop
        	if user clicks stop, return true, and should quit
         * @return true on user clicked "stop" button
         */
        public boolean shouldStop(){
        	
        	if(Utilities.checkStop()){
                threegtest.stopFlag = false;
                wakeLock.release();
                wlw.release();
                return true;
            }else
            	return false;
        
        }

}


