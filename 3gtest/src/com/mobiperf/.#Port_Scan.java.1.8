package eecs.umich.threegtest;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketAddress;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.Random;

import android.util.Log;

public class Port_Scan extends Thread {
	
	public static final int DIRECTION_UP = 1;
	public static final int DIRECTION_DOWN = 2;
	public static final int DIRECTION_BOTH = 3;
	
    private int index;
    public static int activeTest = 0;
   
    /**
     * 
     * @param index
     * @param serverIP
     * @param longTest if true, it is a complete test rather than simple testing blocking 
     * 	(for local use only or FCC)
     */
    
    public Port_Scan(int index){
    	
        this.index = index;
        
        
    }
    public void run(){
    	
		//basic 3GTest reachability test
		shortTest();
    }
    
    
    /**
     * 
     * @param PACKET_SIZE specify total packet size including IP TCP/UDP headers
     *  minimum packet size set to 75 bytes
     * @param NUM_EXP number of experiments
     * @param DIRECTION 1 uplink, 2 downlink, 3 both direction
     * 	For uplink, send PACKET_SIZE to server and server will respond with 1 byte, vice versa for downlink 
     */
    public void rttWithPacketSize(int PACKET_SIZE, int NUM_EXP, int DIRECTION){
    	
    	int port = Service_Thread.PORTS[index];
    	
    	String rubbish = "RUBBISH:";
    	String payload = "RUBBISH:";
    	Random ran = new Random();
    	
    	while(rubbish.length() < 2000){
    		rubbish += ran.nextDouble();
    		rubbish += ran.nextLong();
    		rubbish += ran.nextFloat();
    		rubbish += "hellorubbish";
    	}
    	
    	while(payload.length() < PACKET_SIZE){
    		payload += ran.nextDouble();
    		payload += ran.nextLong();
    		payload += ran.nextFloat();
    		payload += "hellorubbish";
    	}
    	payload = payload.substring(0, PACKET_SIZE);//will cut later depending on packet type
    	
    	Log.v("MobiOpen", "rubbish length " + rubbish.length());
    	Log.v("MobiOpen", "PACKET_SIZE " + PACKET_SIZE + " NUM_EXP " + NUM_EXP + 
    			" payload length " + payload.length());
    	
    	long start, end;
        
        try {
        	
        	warmUpWithUdp(rubbish, 1);
        	
        	String result = "";
        	
        	//NUM_EXP TCP experiments
        	for(int i = 1 ; i <= NUM_EXP ; i++){
        		
        		//promote to DCH
        		if(i % 5 == 0)
        			warmUpWithUdp(rubbish, 1);
        		
	        	Socket tcpSocket = new Socket();
	        	tcpSocket.setSoTimeout(Definition.TCP_TIMEOUT_IN_MILLI);
	            SocketAddress remoteAddr = new InetSocketAddress(Definition.SERVER_NAME, port);
	            DataOutputStream os = null;
	            DataInputStream is = null;
	            
	            //measure latency of establishing TCP connection, is it RTT?
	            //validated by trace
	            
	            byte[] buf = (payload.substring(0, PACKET_SIZE - 
	            		Definition.IP_HEADER_LENGTH - Definition.TCP_HEADER_LENGTH - 
	            		("" + System.currentTimeMillis()).length()) + 
	            		System.currentTimeMillis()).getBytes();
	            byte[] recv_buf = new byte[PACKET_SIZE];
	            
	            start = System.currentTimeMillis();
	            try{
	            	tcpSocket.connect( remoteAddr, Definition.TCP_TIMEOUT_IN_MILLI );
	            }catch ( Exception e ) {
	            }
	            
	            //test connect time
            	end = System.currentTimeMillis();
	            Log.v("MobiOpen", "CONNECT port " + port + 
	            		" run " + i + " res " + (end - start));
	            result += "MobiOpen:CONNECT port " + port + " sequence " + i + " delay " + (end - start) + 
	            	" timestamp " + System.currentTimeMillis() + 
	            	" packet_size " + PACKET_SIZE + "\n";
	            
	            
	            //speed up timeout experiments
	            if((end - start) > 3000){
	            	NUM_EXP -= 3;
	            	continue;
	            }
	            
	            //ignore HTTP SSH HTTPS
                if(port != 80 && port != 22 && port != 443){
                
		            try{
		            	os = new DataOutputStream( tcpSocket.getOutputStream() );
		                is = new DataInputStream( tcpSocket.getInputStream() );
		               
	                	//restart timer
		                start = System.currentTimeMillis();
	                	os.write(buf);
	                	os.flush();
	                	is.read(recv_buf, 0, recv_buf.length);
		            }catch ( Exception e ) {
		            }
		            //end time for both timeout and normal execution
		            end = System.currentTimeMillis();
		            Log.v("MobiOpen", "TCP port " + port + 
		            		" run " + i + " res " + (end - start));
		            result += "MobiOpen:TCP port " + port + " sequence " + i + " delay " + (end - start) + 
		            	" timestamp " + System.currentTimeMillis() + 
		            	" packet_size " + PACKET_SIZE + "\n";
		            if(is != null)
		            	is.close();
		            if(os != null)
		            	os.close();
        		}
	            
	            tcpSocket.close();
        	}
        	
        	//NUM_EXP UDP experiments
        	for(int i = 1 ; i <= NUM_EXP ; i++){
        		
        		//promote to DCH
        		if(i % 5 == 0)
        			warmUpWithUdp(rubbish, 1);

        		DatagramSocket socket = new DatagramSocket();
        		byte[] buf = (payload.substring(0, PACKET_SIZE - 
	            		Definition.IP_HEADER_LENGTH - Definition.UDP_HEADER_LENGTH - 
	            		("" + System.currentTimeMillis()).length()) + 
	            		System.currentTimeMillis()).getBytes();
        		
        		InetAddress address = InetAddress.getByName(Definition.SERVER_NAME);//should this be IP? no..
        		DatagramPacket packet = new DatagramPacket(buf, buf.length, address, port);
        		
        		socket.setSoTimeout(Definition.TCP_TIMEOUT_IN_MILLI);
        		//prepare to receive request
        		byte[] buf2 = new byte[PACKET_SIZE];
		        DatagramPacket p2 = new DatagramPacket(buf2, buf2.length);
		        
		        //send
		        start = System.currentTimeMillis();
        		socket.send(packet);
        		
        		//receive
        		try{
        			socket.receive(p2);
        		}catch ( Exception e ) {
        		}
		        end = System.currentTimeMillis();
		        
		        Log.v("MobiOpen", "UDP port " + port + 
	            		" run " + i + " res " + (end - start));
		        result += "MobiOpen:UDP port " + port + " sequence " + i + " delay " + (end - start) + 
	            	" timestamp " + System.currentTimeMillis() + 
	            	" packet_size " + PACKET_SIZE + "\n";
		        socket.close();
        	}
        	
        	(new Report()).sendReport(result);
        	
        }
        catch ( Exception e ) {
        	e.printStackTrace();
        }

        //let server thread know that it is done
        Service_Thread.rPorts++;
    }
    
    public void warmUpWithUdp(String content, int index) throws IOException{
    	DatagramSocket socket = new DatagramSocket();
		byte[] buf = content.getBytes();
		InetAddress address = InetAddress.getByName(Definition.SERVER_NAME);//should this be IP? no..
		DatagramPacket packet = new DatagramPacket(buf, buf.length, address, Service_Thread.PORTS[index]);
		socket.setSoTimeout(Definition.TCP_TIMEOUT_IN_MILLI);
		//prepare to receive request
		byte[] buf2 = new byte[10000];
        DatagramPacket p2 = new DatagramPacket(buf2, buf2.length);
        
        //send
		socket.send(packet);
		//receive
		socket.receive(p2);
        socket.close();
    }
    
    public void shortTest(){
    	Service_Thread.REACHB[ index ] = false;
    	Service_Thread.REACHBst[ index ] = 'o';
        Socket tcpSocket = null;
        DataOutputStream os = null;
        DataInputStream is = null;

        try {
            tcpSocket = new Socket();
            SocketAddress remoteAddr = new InetSocketAddress(Definition.SERVER_NAME, Service_Thread.PORTS[ index ] );
            tcpSocket.connect( remoteAddr, Definition.TCP_TIMEOUT_IN_MILLI );
            os = new DataOutputStream( tcpSocket.getOutputStream() );
            is = new DataInputStream( tcpSocket.getInputStream() );
            tcpSocket.setSoTimeout( Definition.TCP_TIMEOUT_IN_MILLI );
        }
        catch ( Exception e ) {
        	e.printStackTrace();
        	Service_Thread.REACHBst[ index ] = 'c';
        }

        if ( tcpSocket == null || os == null || is == null ) {
        	Service_Thread.REACHBst[ index ] = 'c';
        }

        else {

            try {
            	String helloString = "hello" + System.currentTimeMillis() + Service_Thread.PORTS[index];
                byte [] message = helloString.getBytes();
                os.write(message);
                os.flush();
                
                byte[] buffer = new byte[ 1000 ];
                int read_bytes = is.read( buffer, 0, 1000 );

                if ( read_bytes != -1 ) {
                    String reply = new String( buffer, 0, read_bytes );
                    Log.v("LOG", "in port scanning " + index + " for port " + Service_Thread.PORTS[index] + 
                    		" the reply message we got is <" + reply + ">, length: " + read_bytes);
                    
                    if(reply.equals(helloString)) {
                    	//Log.v("LOG", "it is the same as hello");
                    	Service_Thread.REACHB[ index ] = true;
                    }
                    else if(Service_Thread.PORTS[index] == 22 && reply.startsWith("SSH")) {
                    	Service_Thread.REACHB[ index ] = true;
                    	
                    	//need to process HTTPS, HTTP here
                    }else{
                    	//Log.v("LOG", "it is different");
                    	Service_Thread.REACHBst[ index ] = 'd';
                    }
                }else{
                	Service_Thread.REACHBst[ index ] = 'd';
                }
                
                os.close();
                is.close();
                tcpSocket.close();
                
            }catch ( Exception e ) {
            	Service_Thread.REACHBst[ index ] = 'd';
                e.printStackTrace();
            }

        }

        //let server thread know that it is done
        Service_Thread.rPorts++;
    }

}
