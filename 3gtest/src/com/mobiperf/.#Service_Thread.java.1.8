package com.mobiperf;
import android.content.Context;
import android.net.wifi.WifiManager;
import android.os.Build;
import android.os.PowerManager;
import android.provider.Settings;
import android.util.Log;


public class Service_Thread extends Thread {
	public static int mProgressStatus;

	public static int rPorts = 0;
	public static int[] PORTS = new int [] {21, 22, 25, 53, /*80,*/
		110, 135, 139, 143, 161, 
		/*443,*/ 445, 465, 585, 587, 
		993, 995, 5060, 6881, 5223, 
		5228, 8080};
	public static boolean [] REACHB = new boolean[ PORTS.length ];
	public static char [] REACHBst = new char[ PORTS.length ];

	public static String infoS;

	private static final String[] PORT_NAMES = new String[] {"FTP", "SSH", "SMTP", "DNS", /*"HTTP",*/
		"POP", "RPC", "NETBIOS", "IMAP", "SNMP", 
		/*"HTTPS",*/  "SMB", "SMTP SSL", "Secure IMAP", "Auth SMTP", 
		"IMAP SSL", "POP SSL", "SIP", "BITTORRENT", "IOS SPECIAL",
		"ANDROID SPECIAL", "HTTP PROXY"};


	public static Threegtest_Service service;
	private static NAT_Test_Thread natThread;
	private static TCP_Injection_Vuln_Test_Thread tcpInjectionVulnTestThread;
	//	private static Spoof_Test_Thread spoofThread;
	private static Probe_Nearby_Test_Thread probeNearbyThread;
	//	private static Timeout_Test_Thread timeoutThread;
	private static Firewall_Test_Thread firewallThread;

	private PowerManager.WakeLock wakeLock;
	private WifiManager.WifiLock wlw;

	public Service_Thread(Threegtest_Service s){
		this.service = s;
		mProgressStatus = 0;
	}

	public void run() {

		long start = System.currentTimeMillis();
		long end = start;
		String message;

		InformationCenter.reset();
		
		Thread binaryThread = Utilities.installBinaries(service);

		//check airplane mode
		service.updateTextView3(Feedback.getMessage(Feedback.TYPE.AIRPLANE_MODE_CHECKING, null));
		boolean isEnabled = Settings.System.getInt( service.getContentResolver(), Settings.System.AIRPLANE_MODE_ON, 0 ) == 1;
		if(isEnabled){
			mProgressStatus = 0;
			service.addResultAndUpdateUI(Feedback.getMessage(Feedback.TYPE.AIRPLANE_MODE_ENABLED, null), mProgressStatus);
			return;
		}
		//ok, now airplane mode is not enabled and we are good to go

		//Threegtest_Service.tester = new ConnectivityThreegtest_Service.tester(context);

		//ensures that CPU and wifi is on, priority is max
		this.setPriority( MAX_PRIORITY );
		PowerManager pm = ( PowerManager ) service.getSystemService( Context.POWER_SERVICE );
		wakeLock = pm.newWakeLock( PowerManager.PARTIAL_WAKE_LOCK, "POWER LOCK TAG" );
		wakeLock.acquire();
		WifiManager wm = ( WifiManager ) service.getSystemService( Context.WIFI_SERVICE );
		wlw = wm.createWifiLock( "WIFI LOCK TAG" );
		wlw.acquire();


		//catch any exception here
		try{

			//checking network connectivity by connecting to google.com
			service.updateTextView3(Feedback.getMessage(Feedback.TYPE.NETWORK_CONNECTION_CHECKING, null));
			if (Utilities.checkConnection()){
				InformationCenter.setNetworkStatus(true);
			}else{
				InformationCenter.setNetworkStatus(false);
			}

			//if no network connection
			if(!InformationCenter.getNetworkStatus()){ 
				mProgressStatus = 0;
				service.addResultAndUpdateUI(Feedback.getMessage(Feedback.TYPE.NETWORK_CONNECTION_DOWN, null), mProgressStatus);
				wakeLock.release();
				wlw.release();
				return;
			}

			//network connection is available, start tests

			//MobiOpen test
			/*service.updateTextView3("MobiPerf local experiments");
				if(1==1){
					while(true){
						long start = System.currentTimeMillis();
						localExperiments("rtt.size");
						//localExperiments("port.scan");
						long end = System.currentTimeMillis();
						service.updateTextView2("last time (sec): " + (end-start)/1000);
						service.updateTextView3("Prefix " + Definition.getPrefix());
						//DNS.LookupUniqueUrl(true);
					}
				}
				//*/
			
			
			service.addResultAndUpdateUI(Feedback.getMessage(Feedback.TYPE.DEVICE_ID, null), mProgressStatus += 2);
			//service.addResultAndUpdateUI(Feedback.getMessage(Feedback.TYPE.RUN_ID, null), mProgressStatus += 2);

			
			//Version information
			(new Report()).sendReport("PACKAGE:<VersionCode:" + InformationCenter.getPackageVersionCode() + "><VersionName:" + 
					InformationCenter.getPackageVersionName() + ">");
			
			//Build information
			(new Report()).sendReport("BUILD:<BOARD:" + Build.BOARD + "><BRAND:" + Build.BRAND + ">" +
					"<DEVICE:" + Build.DEVICE + "><FINGERPRINT:" + Build.FINGERPRINT + "><HOST:" + Build.HOST + ">" +
					"<ID:" + Build.ID + "><MODEL:" + Build.MODEL + "><PRODUCT:" + Build.PRODUCT + ">" +
					"<TAGS:" + Build.TAGS + "><TIME:" + Build.TIME + "><USER:" + Build.USER + "><TYPE:" + Build.TYPE + ">" +
					"<VERSION.SDK:" + Build.VERSION.SDK + "><VERSION.RELEASE:" + Build.VERSION.RELEASE + ">;");
			if(shouldStop())
				return;


			//carrier info, network type, signal strength, cellID
			String carrier = InformationCenter.getNetworkOperator();
			String netInfoS = "NETWORK:" + "<Carrier:" + carrier + ">";
			service.addResultAndUpdateUI(Feedback.getMessage(Feedback.TYPE.CARRIER_NAME, new String[]{carrier}), mProgressStatus += 5);

			String[] networkType = InformationCenter.getTypeNameAndId();
			int cellid = InformationCenter.getCellId();
			int lac = InformationCenter.getLAC();
			int signal = InformationCenter.getSignalStrength();
			netInfoS += "<Type:" + networkType[0] + 
			"><TypeID:" + networkType[1] + 
			"><CellId:" + cellid +
			"><LAC:" + lac +
			"><Signal:" + signal + ">;";

			service.addResultAndUpdateUI(Feedback.getMessage(Feedback.TYPE.NETWORK_TYPE, networkType), mProgressStatus += 1);
			service.addResultAndUpdateUI(Feedback.getMessage(Feedback.TYPE.CELL_ID, new String[]{"" + cellid}), mProgressStatus += 1);
			service.addResultAndUpdateUI(Feedback.getMessage(Feedback.TYPE.LAC, new String[]{"" + lac}), mProgressStatus += 1);
			service.addResultAndUpdateUI(Feedback.getMessage(Feedback.TYPE.SIGNAL_STRENGTH, new String[]{"" + signal}), mProgressStatus += 1);

			threegtest.displayResult("Network Type", "Network type used (WiFi, UMTS, CDMA, etc.)", networkType[0], 0);
			threegtest.displayResult("Carrier", "Name of cellular carrier", carrier, 0);
			threegtest.displayResult("Cell ID", "Id of cell tower connected", "" + cellid, 0);
			threegtest.displayResult("Signal Strength", "Signal strength in asu, 0 is worst and 31 is best", "" + signal, 0);

			(new Report()).sendReport(netInfoS);
			if(shouldStop())
				return;


			//DNS unique lookup to UMICH DNS servers
			DNS.LookupUniqueUrl(false);


			//local ip vs global ip
			if(service.isRoot)
				service.updateTextView3("Testing IP, NAT, and firewall with root...");
			else
				service.updateTextView3("Testing IP, NAT, and firewall...");

			int replyCode = Phone_IPs.Get_Phone_IPs(Definition.SERVER_NAME, Definition.PORT_WHOAMI );


			String result = "ADDRESS:<LocalIp:" + Phone_IPs.localIP + ">:<GlobalIp:" + Phone_IPs.seenIP + ">;";
			String message1;
			if ( replyCode >= 7 ) {
				message = "Local IP address: " + Phone_IPs.localIP;
				message1 = "Global IP address: " + Phone_IPs.seenIP;
			}else{
				message = "Local IP address: Error in test";
				message1 = "Global IP address: Error in test";
			}

			service.addResultAndUpdateUI(message, mProgressStatus += 2);//Local IP
			service.addResultAndUpdateUI(message1, mProgressStatus += 2);//Global IP

			threegtest.displayResult("Local IP", "Local IP address of your device, could be private IP", Phone_IPs.localIP, 0);
			threegtest.displayResult("Seen IP", "IP address of your device seen by a remote server", Phone_IPs.seenIP, 0);

			(new Report()).sendReport(result);
			if(shouldStop())
				return;

			//checking GPS info
			service.updateTextView3(Feedback.getMessage(Feedback.TYPE.GPS_CHECKING, null));
			while(GPS.location == null){
				end = System.currentTimeMillis();
				if(end - start > Definition.GPS_UPDATE_WAITING_TIME){
					GPS.stopAllUpdate();
					GPS.location = GPS.getCurrentLocation();
					GPS.latitude = GPS.location.getLatitude();
					GPS.longitude = GPS.location.getLongitude();
					break;
				}try{
					//Log.v("LOG", "Utilities.Info(), waiting for a GPS result............");
					Thread.sleep(1000);
				}catch (InterruptedException e){
					e.printStackTrace();
				}
			}
			mProgressStatus += 5;
			service.addResultAndUpdateUI(Feedback.getMessage(Feedback.TYPE.GPS_VALUE, null), mProgressStatus);
			threegtest.displayResult("GPS Location", "Latitude (<0 for South) Longitude (<0 for West)", 
					"Latitude:" + GPS.location.getLatitude() + " Longitude:" + GPS.location.getLongitude(), 0);

			infoS = Utilities.Info(service);
			// set report prefix
			(new Report()).sendReport(infoS);
			if(shouldStop())
				return;


			/**** wait till all the binaries are installed ****/
			try {
				binaryThread.join();
			} catch (InterruptedException e3) {
				e3.printStackTrace();
			}
			/*********** NAT Test Thread **************/
			// Make sure only one NAT_Test_Thread instance is running
			if(natThread == null || !natThread.isAlive())
			{
				natThread = new NAT_Test_Thread(service);
				natThread.start();
			}
			else
			{
				if(natThread.isMappingDone)
				{
					message = natThread.getNATMappingMessage();
					service.addResultAndUpdateUI(message, mProgressStatus);
					//Utilities.write_to_file(Service_Thread.LOG_FILE_NAME,Context.MODE_APPEND, message+"\n", service);
				}
				Log.v("MobiPerf_nat", "nat thread is still running");
			}

			/******************************************/
			/*********** Timeout Test Thread **************/
			// Make sure only one timeoutThread instance is running
			/*
				if(timeoutThread == null || !timeoutThread.isAlive()){
					timeoutThread = new Timeout_Test_Thread(service);
					timeoutThread.start();
				}else
					Log.v("MobiPerf_timeout", "timeout thread is still running");
				/******************************************/


			// Similar to NAT thread (testing TCP injection vulnerability)
			if(tcpInjectionVulnTestThread == null || !tcpInjectionVulnTestThread.isAlive())
			{
				tcpInjectionVulnTestThread = new TCP_Injection_Vuln_Test_Thread(service);
				Log.v("TCPvultest", "TCPvultest starts to run!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
				tcpInjectionVulnTestThread.start();
			}
			else
			{
				Log.v("TCPvultest", "TCPvultest thread is still running");
			}

			// Similar to NAT thread (probing nearby IPs)
			if(probeNearbyThread == null || !probeNearbyThread.isAlive())
			{
				probeNearbyThread = new Probe_Nearby_Test_Thread(service);
				probeNearbyThread.start();
			}
			else
			{
				Log.v("probeNearbyThread", "probeNearbyThread test thread is still running");
			}

			/*if(service.isRoot)
		{
			/************* IP Spoofing Test ***********
			// Similar to NAT thread
			if(spoofThread == null || !spoofThread.isAlive())
			{
				spoofThread = new Spoof_Test_Thread(service);
				spoofThread.start();
			}
			else
			{
				Log.v("MobiPerf_spoof", "spoof test thread is still running");
			}
			/******************************************
			/************* Firewall Buffer Test ***********

			// Similar to NAT thread
			if(firewallThread == null || !firewallThread.isAlive())
			{
				firewallThread = new Firewall_Test_Thread(service);
				firewallThread.start();
			}
			else
			{
				Log.v("MobiPerf_firewall", "firewall test thread is still running");
			}
			/******************************************
		}*/



			// DNS request google
			service.updateTextView3("Testing local DNS server...");
			replyCode = DNS.Google();

			if ( DNS.DNSGoogle == true ) {
				message = "Local DNS server status: UP";
			}
			else {
				message = "Local DNS server status: DOWN";
			}
			mProgressStatus = 30;

			threegtest.displayResult("Local DNS server status", "Tests whether your local DNS server works", message, 1);
			service.addResultAndUpdateUI(message, mProgressStatus);//Local DNS server status

			// popular domains
			Parallel_Thread1.thread1DoneFlag = false;
			Parallel_Thread2.thread2DoneFlag = false;
			Landmark.config_file_check(service, Definition.SERVER_NAME);


			service.updateTextView3("Testing network latencies...");
			Thread p1 = new Parallel_Thread1(service);
			p1.start();
			Thread p2 = new Parallel_Thread2(service);
			p2.start();
			try {
				// Service_Thread waits Paralel_Thread1
				p1.join();
			} catch (InterruptedException e1) {
				e1.printStackTrace();
			}
			service.updateTextView3("Testing network latencies...");
			try {
				// Service_Thread waits Paralel_Thread2
				p2.join();
			} catch (InterruptedException e1) {
				e1.printStackTrace();
			}



			//DNS to external server allowed?
			result = "DNS:";
			replyCode = DNS.dnsLookupToExternalServer(Definition.SERVER_NAME, Definition.PORT_DNS);

			mProgressStatus = 50;
			if ( DNS.DNSUmich == true ) {
				message = "DNS lookup to external server allowed?: Yes";
				result += "<DnsToExternalServerAllowed: Yes>";
			}else if ( replyCode == 6 ) {
				message = "DNS lookup to external server allowed?: No";
				result += "<DnsToExternalServerAllowed: No>";
			}else if ( replyCode == 4 ) {
				message = "DNS lookup to external server allowed?: No";
				result += "<DnsToExternalServerAllowed: No>";
			}else {
				message = "DNS lookup to external server allowed?: Error in test";
				result += "<DnsToExternalServerAllowed: Error in test>";
			}
			service.addResultAndUpdateUI(message, mProgressStatus);//DNS lookup to external server
			threegtest.displayResult("DNS lookup to external server", "Tests whether your ISP blocks DNS traffic to external server", message, 2);

			result += ";";
			(new Report()).sendReport(result);
			if(shouldStop())
				return;



			// HTTP proxy caching tests (currently disabled to speed up the test)

			/* strt = System.currentTimeMillis();

                    replyCode = Caching_Compression.http_caching(HTTP_SERVER_IP, PORT_CACHING);


                    result = "HTTP:";

                    if ( replyCode != 12 ) {
                        message = "HTTP caching detection: Error in test";
                        result += "<Cache: Error>:";
                    }
                    else {
                        if ( Caching_Compression.cacheFlag == true ) {
                            message = "HTTP caching detection: Detected";
                            result += "<Cache: Yes>:";
                        }
                        else {
                            message = "Http Caching detection: Not detected";
                            result += "<Cache: No>:";
                        }
                    }

                    if ( replyCode != 12 ) {
                        message = "Http Proxy detection: Error in test";
                        result += "<Compression: Error>;";
                    }
                    else {
                        if ( Caching_Compression.compressionFlag == true ) {
                            message = "Http Proxy detection: Detected";
                            result += "<Compression: Yes>;";
                        }
                        else {
                            message = "Http Proxy detection: Not detected";
                            result += "<Compression: No>;";
                        }
                    }
                    result += "\n";
                    Report.sendReport( serverIP, result, PORT_CONTROL );
                    if(shouldStop())
						return;
			 */



			// bit torrent differentiation (currently disabled to speed up the test)

			/*

                    //// random bit torrent
                    replyCode = BT.BTptosUp( serverIP, PORT_BT_RAND, context );

                    result = "BT:";

                    if ( BT.BTBlockedStage.equals( "E" ) ) {
                        message = "BitTorrent uplink traffic: No blocking ";
                        result += "<NondftUpBlockedStage: NONE>;";
                    }
                    else if ( BT.BTBlockedStage.equals( "S" ) ) {
                        message = "BitTorrent uplink traffic: Error in test";
                        result += "<NondftUpBlockedStage: Error>;";
                    }
                    else {
                        message = "BitTorrent uplink traffic: Blocked ";
                        result += "<NondftUpBlockedStage: " + BT.BTBlockedStage + ">;";
                    }

                    result += "\n";
                    Report.sendReport( serverIP, result, PORT_CONTROL );
                    if(shouldStop())
            			return;


                    replyCode = BT.BTptosUp( serverIP, PORT_BT , context );

                    result = "BT:";

                    if ( BT.BTBlockedStage.equals( "E" ) ) {
                        message = "BitTorrent uplink traffic: No blocking ";
                        result += "<DftUpBlockedStage: None>;";
                    }
                    else if ( BT.BTBlockedStage.equals( "S" ) ) {
                        message = "BitTorrent uplink traffic: Error in test";
                        result += "<DftUpBlockedStage: Error>;";
                    }
                    else {
                        message = "BitTorrent uplink traffic: Blocked ";
                        result += "<DftUpBlockedStage: " + BT.BTBlockedStage + ">;";
                    }

                    mProgressStatus = Utilities.setProgressStatus (42);
                    Utilities.write_to_file(FILENAME, Context.MODE_APPEND,message + "\n"+ mProgressStatus + "\n", context );
                    Utilities.write_to_file(LOG_FILE_NAME, Context.MODE_APPEND,message + "\n", context);
                    Utilities.sendudpmessage( uiFile, "" + message.length() + "!" + message + "" + mProgressStatus + "!", context );
                    if ( Utilities.destinationreached == false )
                    	Traceroute.method(serverIP, PORT_CONTROL,5, 10);
                    result += "\n";
                    Report.sendReport( serverIP, result, PORT_CONTROL );
					if(shouldStop())
            			return;
                    replyCode = BT.BTptosDown( serverIP, PORT_BT_RAND, context );


                    result = "BT:";
                    if ( BT.BTBlockedStage.equals( "E" ) ) {
                        message = "BitTorrent downlink traffic: No blocking ";
                        result += "<NondftDownBlockedStage: None>;";
                    }
                    else if ( BT.BTBlockedStage.equals( "S" ) ) {
                        message = "BitTorrent downlink traffic: Error in test";
                        result += "<NondftDownBlockedStage: Error>;";
                    }
                    else {
                        message = "BitTorrent downlink traffic: Blocked at " +BT.BTBlockedStage;
                        result += "<NondftDownBlockedStage: " + BT.BTBlockedStage + ">;";
                    }
                    result += "\n";
                    Report.sendReport( serverIP, result, PORT_CONTROL );
                    if(shouldStop())
            			return;

                    result = "BT:";

                    replyCode = BT.BTptosDown( serverIP, PORT_BT , context );


                    if ( BT.BTBlockedStage.equals( "E" ) ) {
                        message = "BitTorrent downlink traffic: No blocking ";
                        result += "<DftDownBlockedStage: None>;";
                    }
                    else if ( BT.BTBlockedStage.equals( "S" ) ) {
                        message = "BitTorrent downlink traffic: Error in test";
                        result += "<DftDownBlockedStage: Error>;";
                    }
                    else {
                        message = "BitTorrent downlink traffic: Blocked ";
                        result += "<DftDownBlockedStage: " + BT.BTBlockedStage + ">;";
                    }

                    mProgressStatus = Utilities.setProgressStatus (56);
                    Utilities.write_to_file(FILENAME, Context.MODE_APPEND ,message + "\n"+mProgressStatus + "\n", context );
                    Utilities.write_to_file(LOG_FILE_NAME, Context.MODE_APPEND,message + "\n", context );
                    Utilities.sendudpmessage( uiFile, "" + message.length() + "!" + message + "" + mProgressStatus + "!", context );
                    if ( Utilities.destinationreached == false )
                    	Traceroute.method(serverIP, PORT_CONTROL,10,15);
                    result += "\n";
                    Report.sendReport( serverIP, result, PORT_CONTROL );
                    if(shouldStop())
            			return;

                    /// random
                    replyCode = BT.BTRandom( serverIP, PORT_BT );

                    result = "BT:";

                    if ( replyCode < 5 ) {
                        result += "<RandomBlockedStage: SYN>;";
                    }
                    else if ( replyCode < 10 ) {
                        result += "<RandomBlockedStage: Transfer>;";
                    }
                    else {
                        result += "<RandomBlockedStage: None>;";
                    }

                    result += "\n";
                    Report.sendReport( serverIP, result, PORT_CONTROL );
                    if(shouldStop())
            			return;

                    replyCode = HTTP.HTTPptosUp( serverIP, PORT_HTTP, context );
                    replyCode = HTTP.HTTPptosDown( serverIP, PORT_HTTP, context );
			 */



			///reachability test wrapper
			//TODO no reachability test for now
			if(testReachability())
				return;


			// downlink tput
			service.updateTextView3("Testing downlink throughput...");
			replyCode = Throughput.MeasureDownlinkTput(Definition.SERVER_NAME, Definition.PORT_THRU_DOWN);

			result = "DOWN:";

			if ( replyCode == 7 ) {

				double downtp = (Throughput.downlinkSize * 8 ) / Throughput.downlinkTime; // in kbps

				message = "TCP downlink bandwidth (kbps): " + downtp;
				result += "<Tp:" + downtp + ">";


				if ( downtp > 500 )
					message += " Good";
				else if ( downtp > 130 )
					message += " Moderate";
				else
					message += " Bad";
			}
			else {
				message = "TCP downlink bandwidth (kbps): Network problem in test";
				result += "<Tp:-1>";
			}

			mProgressStatus = 90;

			service.addResultAndUpdateUI(message, mProgressStatus);//TCP down
			threegtest.displayResult("Downlink throughput", "How many bits per second can be downloaded in TCP", message, 1);

			result += ";";
			result += "\n";
			(new Report()).sendReport(result);
			if(shouldStop())
				return;

			// uplink tput   
			service.updateTextView3("Testing uplink throughput...");

			replyCode = Throughput.MeasureUplinkTput(Definition.SERVER_NAME, Definition.PORT_THRU_UP);                    

			result = "UP:";

			if ( replyCode == 7 ) {
				//double uptp = Throughput.uplinkSize / ( 128 * 60 );//old mistaken one
				double uptp = (Throughput.uplinkSize * 8) / Throughput.uplinkTime;
				message = "TCP uplink bandwidth (kbps): " + uptp;
				result += "<Tp:" + uptp + ">";

				if ( uptp > 100 )
					message += " Good";
				else if ( uptp > 30 )
					message += " Moderate";
				else
					message += " Bad";
			}
			else {
				message = "TCP uplink bandwidth (kbps): Network problem in test";
				result += "<Tp:-1>";
			}

			mProgressStatus = 100;
			result += ";";
			result += "\n";
			(new Report()).sendReport(result);
			if(shouldStop())
				return;


			Log.v("error"," dis is "+message);
			service.addResultAndUpdateUI(message, mProgressStatus);//TCP UP
			threegtest.displayResult("Uplink throughput", "How many bits per second can be uploaded in TCP", message, 1);


			//traceroute experiments to our server
			//TODO
			//Traceroute.traceroute(Def.SERVER_NAME, -1, -1);


		}catch(Exception e){
			System.out.println("The outer big try in Service_Thread.java");
			e.printStackTrace();
		}

		//let server write to database
		Utilities.letServerWriteOutputToMysql();

		wakeLock.release();
		wlw.release();

		end = System.currentTimeMillis();
		Log.v("MobiPerf", "service thread finish using " + (end - start) / 1000 +"s");

	}


	/**
	 * For FCC challenge or local experiments
	 * Test both latency to TCP and UDP server with the list of ports
	 * @return
	 */
	public void localExperiments(String type){
		if(type.equalsIgnoreCase("port.scan")){
			for(int j = 0; j < PORTS.length; j++){
				new Port_Scan(j).rttWithPacketSize(100, 25, Port_Scan.DIRECTION_DOWN);
			}
		}else if(type.equalsIgnoreCase("rtt.size")){
			int NUM_EXP = 10;
			for(int s = 100 ; s <= 2000 ; s += 25){
				for(int direction : new int[]{Port_Scan.DIRECTION_DOWN, 
						Port_Scan.DIRECTION_UP, Port_Scan.DIRECTION_BOTH}){
					new Port_Scan(0).rttWithPacketSize(s, NUM_EXP, direction);//port 21
					new Port_Scan(3).rttWithPacketSize(s, NUM_EXP, direction);//port 53
					new Port_Scan(20).rttWithPacketSize(s, NUM_EXP, direction);//port 5228
				}
			}
		}
	}


	/**
	 * Test reachability of PORTS.length ports
	 * @return true when stop button clicked and should return for upper layer
	 */

	public boolean testReachability(){
		service.updateTextView3("Testing port blocking...");
		rPorts = 0;

		for(int j = 0; j < PORTS.length; j++){

			new Port_Scan(j).start();

			//wait a little while before staring new thread
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}

		do {
			try {
				//sleep for 1 sec
				Thread.sleep( 1000 );
			}catch ( InterruptedException e ) {
				e.printStackTrace();
			}
		}while(rPorts < PORTS.length);

		String result = "REA";
		String blocked = "Blocked ports for direct access: ";
		String allowed = "Allowed ports for direct access: ";

		for ( int i = 0; i < REACHB.length;i++ ){
			result += ":";
			Log.v("LOG", "REACHB result " + i + " for port " + PORTS[i] + " is " + REACHB[i]);
			if ( REACHB[ i ] == false ) {
				blocked += PORTS[ i ] + " (" + PORT_NAMES[ i ] + ")" + " ";
				if ( REACHBst[ i ] == 'c' )
					result += "<" + PORTS[ i ] + ": CONNECT>";
				else
					result += "<" + PORTS[ i ] + ": RECV>";
			}else {
				allowed += PORTS[ i ] + " (" + PORT_NAMES[ i ] + ")" + " ";
				result += "<" + PORTS[ i ] + ": OK>";
			}
		}

		mProgressStatus = 80;
		//Utilities.write_to_file(FILENAME, Context.MODE_APPEND ,message + "\n"+mProgressStatus + "\n"+message1 + "\n"+mProgressStatus + "\n", context );
		//Utilities.sendudpmessage( uiFile, "" + message.length() + "!" + message + "" + mProgressStatus + "!", context );
		service.addResultAndUpdateUI(blocked, mProgressStatus);//disallowed ports
		//Utilities.write_to_file(LOG_FILE_NAME, Context.MODE_APPEND, message + "\n"+message1 + "\n", service  );
		//Utilities.sendudpmessage( uiFile, "" + message1.length() + "!" + message1 + "" + mProgressStatus + "!", context );
		service.addResultAndUpdateUI(allowed, mProgressStatus);//allowed ports
		threegtest.displayResult("Blocked ports", "Either connection is not set up, or data packets are blocked", blocked, 2);
		threegtest.displayResult("Allowed ports", "Data on these ports can be uploaded/downloaded", allowed, 2);
		result += ";";
		(new Report()).sendReport(result);

		if(shouldStop())
			return true;
		else
			return false;
	}


	/**
	 *  use this to check stop
        	if user clicks stop, return true, and should quit
	 * @return true on user clicked "stop" button
	 */
	public boolean shouldStop(){

		if(Utilities.checkStop()){
			threegtest.stopFlag = false;
			wakeLock.release();
			wlw.release();

			//if stops here, write to db, otherwise, will write to db in the end
			Utilities.letServerWriteOutputToMysql();

			return true;
		}else
			return false;

	}

}
